import { createClient, WebDAVClient } from 'webdav'

// WebDAV文件信息接口
export interface WebDAVFileInfo {
  filename: string
  basename: string
  lastmod: string
  size: number
  type: 'file' | 'directory'
  etag?: string
  mime?: string
}

// WebDAV操作结果接口
export interface WebDAVOperationResult<T = any> {
  success: boolean
  data?: T
  error?: string
}

// WebDAV配置接口
export interface WebDAVConfig {
  enabled: boolean
  serverUrl: string
  username: string
  password: string
  appName: string
  autoSync: boolean
  syncPath: string
  lastSyncTime: string | null
  connectionStatus: 'disconnected' | 'connecting' | 'connected' | 'error'
  useProxy?: boolean // 是否使用代理（默认false）
}

/**
 * 获取代理后的URL
 * @param originalUrl 原始URL
 * @param useProxy 是否使用代理
 * @returns 处理后的URL
 */
function getProcessedUrl(originalUrl: string, useProxy: boolean = false): string {
  // 只有在明确指定使用代理且在开发环境中才使用代理
  if (useProxy && import.meta.env.DEV && originalUrl.includes('dav.jianguoyun.com')) {
    const url = new URL(originalUrl)
    // 提取路径部分，去掉 /dav 前缀
    let pathname = url.pathname
    if (pathname.startsWith('/dav/')) {
      pathname = pathname.substring(4) // 去掉 '/dav'
    } else if (pathname === '/dav') {
      pathname = '/' // 根目录
    }
    // 如果路径为空，设为根路径
    if (pathname === '') {
      pathname = '/'
    }
    return `/webdav${pathname}`
  }
  return originalUrl
}

// WebDAV客户端封装类
export class WebDAVService {
  private client: WebDAVClient | null = null
  private config: WebDAVConfig | null = null

  /**
   * 初始化WebDAV客户端
   * @param config WebDAV配置
   */
  async initialize(config: WebDAVConfig): Promise<WebDAVOperationResult<boolean>> {
    try {
      this.config = config
      
      if (!config.serverUrl || !config.username || !config.password) {
        return {
          success: false,
          error: 'WebDAV配置不完整，需要服务器地址、用户名和密码'
        }
      }

      // 获取处理后的URL（根据配置决定是否使用代理）
      const processedUrl = getProcessedUrl(config.serverUrl, config.useProxy || false)
      console.log('初始化WebDAV客户端，原始URL:', config.serverUrl)
      console.log('初始化WebDAV客户端，处理后URL:', processedUrl)
      console.log('使用代理:', config.useProxy || false)

      // 创建WebDAV客户端
      this.client = createClient(processedUrl, {
        username: config.username,
        password: config.password,
        headers: {
          'User-Agent': 'md-reader/1.0'
        }
      })

      // 测试连接
      const testResult = await this.testConnection()
      if (!testResult.success) {
        this.client = null
        return testResult
      }

      return { success: true, data: true }
    } catch (error) {
      return {
        success: false,
        error: `WebDAV客户端初始化失败: ${error instanceof Error ? error.message : '未知错误'}`
      }
    }
  }

  /**
   * 测试WebDAV连接
   */
  async testConnection(): Promise<WebDAVOperationResult<boolean>> {
    if (!this.client) {
      return { success: false, error: 'WebDAV客户端未初始化' }
    }

    try {
      // 尝试获取根目录内容来测试连接
      await this.client.getDirectoryContents('/')
      return { success: true, data: true }
    } catch (error) {
      let errorMessage = '连接失败'
      
      if (error instanceof Error) {
        if (error.message.includes('401') || error.message.includes('Unauthorized')) {
          errorMessage = '认证失败，请检查用户名和密码'
        } else if (error.message.includes('404') || error.message.includes('Not Found')) {
          errorMessage = '服务器地址不正确'
        } else if (error.message.includes('ENOTFOUND') || error.message.includes('Network')) {
          errorMessage = '网络连接失败，请检查服务器地址'
        } else {
          errorMessage = error.message
        }
      }
      
      return { success: false, error: errorMessage }
    }
  }

  /**
   * 获取目录内容
   * @param path 目录路径
   * @param deep 是否递归获取子目录
   */
  async getDirectoryContents(
    path: string = '/', 
    deep: boolean = false
  ): Promise<WebDAVOperationResult<WebDAVFileInfo[]>> {
    if (!this.client) {
      return { success: false, error: 'WebDAV客户端未初始化' }
    }

    try {
      // 确保路径格式正确
      let normalizedPath = path
      
      // 清理路径，移除 ../dav/ 前缀
      if (normalizedPath.startsWith('../dav/')) {
        normalizedPath = normalizedPath.replace('../dav/', '/')
      }
      
      if (!normalizedPath.startsWith('/')) {
        normalizedPath = '/' + normalizedPath
      }
      
      console.log('请求目录内容，路径:', normalizedPath)
      const contents = await this.client.getDirectoryContents(normalizedPath, { deep })
      
      // 转换文件信息格式
      const fileList: WebDAVFileInfo[] = (contents as any[]).map(item => {
        let filename = item.filename
        
        // 如果返回的是绝对URL，转换为相对路径
        if (filename.startsWith('http://localhost:5174/dav/')) {
          filename = filename.replace('http://localhost:5174/dav/', '/')
        } else if (filename.startsWith('https://dav.jianguoyun.com/dav/')) {
          filename = filename.replace('https://dav.jianguoyun.com/dav/', '/')
        }
        
        return {
          filename: filename,
          basename: item.basename,
          lastmod: item.lastmod,
          size: item.size || 0,
          type: item.type,
          etag: item.etag,
          mime: item.mime
        }
      })

      console.log('返回文件列表:', fileList.map(f => ({ name: f.basename, filename: f.filename })))
      return { success: true, data: fileList }
    } catch (error) {
      console.error('获取目录内容失败:', error)
      return {
        success: false,
        error: `获取目录内容失败: ${error instanceof Error ? error.message : '未知错误'}`
      }
    }
  }

  /**
   * 获取支持的文件类型（md、txt等）
   * @param path 目录路径
   */
  async getSupportedFiles(path: string = '/'): Promise<WebDAVOperationResult<WebDAVFileInfo[]>> {
    const result = await this.getDirectoryContents(path, true)
    
    if (!result.success || !result.data) {
      return result
    }

    // 过滤出支持的文件类型
    const supportedExtensions = ['.md', '.markdown', '.txt']
    const supportedFiles = result.data.filter(file => 
      file.type === 'file' && 
      supportedExtensions.some(ext => file.basename.toLowerCase().endsWith(ext))
    )
  }
}

  /**
   * 通过Vite代理下载文件
   * @param filePath 文件路径
   * @param format 返回格式
   */
  private async downloadViaProxy(filePath: string, format: 'text' | 'binary' = 'text'): Promise<WebDAVOperationResult<string | ArrayBuffer>> {
    if (!this.config) {
      return { success: false, error: 'WebDAV配置未找到' }
    }

    try {
      console.log('通过Vite代理下载文件:', filePath, '格式:', format)
      
      // 对路径进行 URL 编码，但保留 / 分隔符
      const encodedPath = filePath.split('/').map(segment => 
        segment ? encodeURIComponent(segment) : ''
      ).join('/')
      
      // 构建代理URL，使用 /webdav 路径
      const proxyUrl = `/webdav${encodedPath}`
      console.log('代理URL:', proxyUrl)
      
      // 使用fetch下载
      const response = await fetch(proxyUrl, {
        method: 'GET',
        headers: {
          'Authorization': 'Basic ' + btoa(`${this.config.username}:${this.config.password}`),
          'User-Agent': 'md-reader/1.0'
        }
      })
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      
      console.log('代理下载响应状态:', response.status, response.statusText)
      console.log('Content-Length:', response.headers.get('content-length'))
      
      // 根据格式返回数据
      if (format === 'text') {
        const textContent = await response.text()
        console.log('代理下载成功，文本长度:', textContent.length, '字符')
        return { success: true, data: textContent }
      } else {
        const arrayBuffer = await response.arrayBuffer()
        console.log('代理下载成功，大小:', arrayBuffer.byteLength, '字节')
        return { success: true, data: arrayBuffer }
      }
      
    } catch (error) {
      console.error('代理下载失败:', error)

try {
  // 尝试获取根目录内容来测试连接
  await this.client.getDirectoryContents('/')
  return { success: true, data: true }
} catch (error) {
  let errorMessage = '连接失败'
  
  if (error instanceof Error) {
    if (error.message.includes('401') || error.message.includes('Unauthorized')) {
      errorMessage = '认证失败，请检查用户名和密码'
    } else if (error.message.includes('404') || error.message.includes('Not Found')) {
      errorMessage = '服务器地址不正确'
    } else if (error.message.includes('ENOTFOUND') || error.message.includes('Network')) {
      errorMessage = '网络连接失败，请检查服务器地址'
    } else {
      errorMessage = error.message
    }
  }
  
  return { success: false, error: errorMessage }
}
}

/**
* 获取目录内容
* @param path 目录路径
* @param deep 是否递归获取子目录
*/
async getDirectoryContents(
path: string = '/', 
deep: boolean = false
): Promise<WebDAVOperationResult<WebDAVFileInfo[]>> {
if (!this.client) {
  return { success: false, error: 'WebDAV客户端未初始化' }
}

try {
  // 确保路径格式正确
  let normalizedPath = path
  
  // 清理路径，移除 ../dav/ 前缀
  if (normalizedPath.startsWith('../dav/')) {
    normalizedPath = normalizedPath.replace('../dav/', '/')
  }
  
  if (!normalizedPath.startsWith('/')) {
    normalizedPath = '/' + normalizedPath
  }
  
  console.log('请求目录内容，路径:', normalizedPath)
  const contents = await this.client.getDirectoryContents(normalizedPath, { deep })
  
  // 转换文件信息格式
  const fileList: WebDAVFileInfo[] = (contents as any[]).map(item => {
    let filename = item.filename
    
    // 如果返回的是绝对URL，转换为相对路径
    if (filename.startsWith('http://localhost:5174/dav/')) {
      filename = filename.replace('http://localhost:5174/dav/', '/')
    } else if (filename.startsWith('https://dav.jianguoyun.com/dav/')) {
      filename = filename.replace('https://dav.jianguoyun.com/dav/', '/')
    }
    
    return {
      filename: filename,
      basename: item.basename,
      lastmod: item.lastmod,
      size: item.size || 0,
      type: item.type,
      etag: item.etag,
      mime: item.mime
    }
  })

  console.log('返回文件列表:', fileList.map(f => ({ name: f.basename, filename: f.filename })))
  return { success: true, data: fileList }
} catch (error) {
  console.error('获取目录内容失败:', error)
  return {
    success: false,
    error: `获取目录内容失败: ${error instanceof Error ? error.message : '未知错误'}`
  }
}
}

/**
* 获取支持的文件类型（md、txt等）
* @param path 目录路径
*/
async getSupportedFiles(path: string = '/'): Promise<WebDAVOperationResult<WebDAVFileInfo[]>> {
const result = await this.getDirectoryContents(path, true)
  
if (!result.success || !result.data) {
  return result
}

// 过滤出支持的文件类型
const supportedExtensions = ['.md', '.markdown', '.txt']
const supportedFiles = result.data.filter(file => 
  file.type === 'file' && 
  supportedExtensions.some(ext => file.basename.toLowerCase().endsWith(ext))
)
}

/**
* 通过Vite代理下载文件
* @param filePath 文件路径
* @param format 返回格式
*/
private async downloadViaProxy(filePath: string, format: 'text' | 'binary' = 'text'): Promise<WebDAVOperationResult<string | ArrayBuffer>> {
if (!this.config) {
  return { success: false, error: 'WebDAV配置未找到' }
}

try {
  console.log('通过Vite代理下载文件:', filePath, '格式:', format)
  
  // 对路径进行 URL 编码，但保留 / 分隔符
  const encodedPath = filePath.split('/').map(segment => 
    segment ? encodeURIComponent(segment) : ''
  ).join('/')
  
  // 构建代理URL，使用 /webdav 路径
  const proxyUrl = `/webdav${encodedPath}`
  console.log('代理URL:', proxyUrl)
  
  // 使用fetch下载
  const response = await fetch(proxyUrl, {
    method: 'GET',
    headers: {
      'Authorization': 'Basic ' + btoa(`${this.config.username}:${this.config.password}`),
      'User-Agent': 'md-reader/1.0'
    }
  })
  
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`)
  }
  
  console.log('代理下载响应状态:', response.status, response.statusText)
  console.log('Content-Length:', response.headers.get('content-length'))
  
  // 根据格式返回数据
  if (format === 'text') {
    const textContent = await response.text()
    console.log('代理下载成功，文本长度:', textContent.length, '字符')
    return { success: true, data: textContent }
  } else {
    const arrayBuffer = await response.arrayBuffer()
    console.log('代理下载成功，大小:', arrayBuffer.byteLength, '字节')
    return { success: true, data: arrayBuffer }
  }
  
} catch (error) {
  console.error('代理下载失败:', error)
  return {
    success: false,
    error: `代理下载失败: ${error instanceof Error ? error.message : '未知错误'}`
  }
}
}

/**
* 下载文件并转换为File对象
* @param filePath 文件路径
* @param fileName 文件名（可选，用于避免特殊字符问题）
*/
async downloadFileAsFile(filePath: string, fileName?: string): Promise<WebDAVOperationResult<File>> {
if (!this.client) {
  return { success: false, error: 'WebDAV客户端未初始化' }
}

try {
  console.log('开始下载文件:', filePath, fileName)
  
  // 标准化文件路径
  let normalizedPath = filePath
  if (normalizedPath.startsWith('../dav/')) {
    normalizedPath = normalizedPath.replace('../dav/', '/')
  }
  if (!normalizedPath.startsWith('/')) {
    normalizedPath = '/' + normalizedPath
  }
  
  // 获取文件内容 - 使用文本格式
  const contentResult = await this.getFileContents(normalizedPath, 'text')
  if (!contentResult.success || !contentResult.data) {
    console.error('获取文件内容失败:', contentResult.error)
    return {
      success: false,
      error: contentResult.error || '获取文件内容失败'
    }
  }

  console.log('文件内容获取成功，长度:', contentResult.data.length)
  
  // 使用提供的文件名或从路径中提取
  const finalFileName = fileName || normalizedPath.split('/').pop() || 'downloaded_file.md'
  
  // 创建File对象
  const file = new File([contentResult.data], finalFileName, {
    type: this.getMimeType(finalFileName)
  })

  console.log('File对象创建成功:', file.name, '大小:', file.size, '类型:', file.type)
  
  return { success: true, data: file }
} catch (error) {
  console.error('下载文件异常:', error)
  return {
    success: false,
    error: `下载文件失败: ${error instanceof Error ? error.message : '未知错误'}`
  }
}
}

/**
* Base64 字符串转 ArrayBuffer
* @param base64 Base64 编码的字符串
* @private
*/
private base64ToArrayBuffer(base64: string): ArrayBuffer {
const binaryString = atob(base64)
const bytes = new Uint8Array(binaryString.length)
for (let i = 0; i < binaryString.length; i++) {
  bytes[i] = binaryString.charCodeAt(i)
}
return bytes.buffer
}

/**
* 获取文件MIME类型
* @param fileName 文件名
*/
private getMimeType(fileName: string): string {
const extension = fileName.toLowerCase().split('.').pop()
switch (extension) {
  case 'md':
  case 'markdown':
    return 'text/markdown'
  case 'txt':
    return 'text/plain'
  case 'json':
    return 'application/json'
  case 'pdf':
    return 'application/pdf'
  case 'epub':
    return 'application/epub+zip'
  default:
    return 'application/octet-stream'
}
}

/**
* 检查文件是否存在
* @param filePath 文件路径
*/
async exists(filePath: string): Promise<boolean> {
if (!this.client) {
  return false
}

try {
  return await this.client.exists(filePath)
} catch (error) {
  console.error('检查文件存在性失败:', error)
  return false
}
}

/**
* 断开连接
*/
disconnect(): void {
this.client = null
this.config = null
}

/**
* 检查是否已初始化
*/
isInitialized(): boolean {
return this.client !== null
}

// 创建单例实例
export const webdavService = new WebDAVService()
